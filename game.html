<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris by Tsheten</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: #1a1a2e;
      color: #eee;
      font-family: system-ui, sans-serif;
    }
    h1 { margin: 0 0 0.5rem 0; font-size: 1.5rem; }
    .score-row {
      margin-bottom: 0.5rem;
      font-size: 1.25rem;
    }
    .score-row span#score { font-weight: bold; }
    #game-over {
      display: none;
      position: absolute;
      background: rgba(0,0,0,0.85);
      padding: 1.5rem 2rem;
      border-radius: 8px;
      text-align: center;
      z-index: 10;
    }
    #game-over.visible { display: block; }
    #game-over p { margin: 0 0 1rem 0; font-size: 1.25rem; }
    button {
      padding: 0.5rem 1rem;
      font-size: 1rem;
      cursor: pointer;
      background: #4a4a6a;
      color: #fff;
      border: none;
      border-radius: 4px;
    }
    button:hover { background: #5a5a7a; }
    .wrap { position: relative; }
    canvas {
      display: block;
      background: #16213e;
      border: 2px solid #0f3460;
    }
    .hint { margin-top: 0.5rem; font-size: 0.85rem; color: #888; }
  </style>
</head>
<body>
  <h1>Tetris</h1>
  <div class="score-row">Score: <span id="score">0</span></div>
  <div class="wrap">
    <canvas id="canvas" width="300" height="600"></canvas>
    <div id="game-over">
      <p>Game Over</p>
      <button id="restart-btn">New Game</button>
    </div>
  </div>
  <p class="hint">Arrow keys: move / rotate. R: restart.</p>

  <script>
    (function () {
      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = 30;
      const FALL_MS = 500;
      const SCORE_PER_LINE = [0, 100, 200, 400, 800];

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      const scoreEl = document.getElementById('score');
      const gameOverEl = document.getElementById('game-over');
      const restartBtn = document.getElementById('restart-btn');

      const COLORS = [
        null,
        '#00f0f0', // I cyan
        '#f0f000', // O yellow
        '#a000f0', // T purple
        '#00f000', // S green
        '#f00000', // Z red
        '#0000f0', // J blue
        '#f0a000', // L orange
      ];

      const SHAPES = [
        null,
        [[1,1,1,1]],
        [[2,2],[2,2]],
        [[0,3,0],[3,3,3]],
        [[0,4,4],[4,4,0]],
        [[5,5,0],[0,5,5]],
        [[6,0,0],[6,6,6]],
        [[0,0,7],[7,7,7]],
      ];

      function createBoard() {
        return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
      }

      function getPieceShape(type, rotation) {
        let shape = SHAPES[type].map(row => [...row]);
        for (let r = 0; r < rotation % 4; r++) {
          const rows = shape.length;
          const cols = shape[0].length;
          const next = Array.from({ length: cols }, (_, i) =>
            Array.from({ length: rows }, (_, j) => shape[rows - 1 - j][i])
          );
          shape = next;
        }
        return shape;
      }

      let board = createBoard();
      let piece = { type: 0, rotation: 0, x: 0, y: 0 };
      let score = 0;
      let gameOver = false;
      let fallTimer = null;

      function canPlace(shape, px, py) {
        for (let row = 0; row < shape.length; row++) {
          for (let col = 0; col < shape[row].length; col++) {
            if (!shape[row][col]) continue;
            const nx = px + col;
            const ny = py + row;
            if (nx < 0 || nx >= COLS || ny >= ROWS) return false;
            if (ny >= 0 && board[ny][nx]) return false;
          }
        }
        return true;
      }

      function lockPiece() {
        const shape = getPieceShape(piece.type, piece.rotation);
        for (let row = 0; row < shape.length; row++) {
          for (let col = 0; col < shape[row].length; col++) {
            if (!shape[row][col]) continue;
            const ny = piece.y + row;
            const nx = piece.x + col;
            if (ny >= 0 && ny < ROWS && nx >= 0 && nx < COLS) {
              board[ny][nx] = shape[row][col];
            }
          }
        }
        clearLines();
        spawnNext();
      }

      function clearLines() {
        let cleared = 0;
        for (let row = ROWS - 1; row >= 0; row--) {
          if (board[row].every(cell => cell !== 0)) {
            board.splice(row, 1);
            board.unshift(Array(COLS).fill(0));
            cleared++;
            row++;
          }
        }
        if (cleared > 0) {
          score += SCORE_PER_LINE[cleared] || 400;
          scoreEl.textContent = score;
        }
      }

      function spawnNext() {
        piece.type = 1 + Math.floor(Math.random() * 7);
        piece.rotation = 0;
        piece.x = Math.floor((COLS - getPieceShape(piece.type, 0)[0].length) / 2);
        piece.y = 0;
        if (!canPlace(getPieceShape(piece.type, piece.rotation), piece.x, piece.y)) {
          gameOver = true;
          if (fallTimer) clearInterval(fallTimer);
          fallTimer = null;
          gameOverEl.classList.add('visible');
          draw();
        }
      }

      function tick() {
        if (gameOver) return;
        const shape = getPieceShape(piece.type, piece.rotation);
        if (canPlace(shape, piece.x, piece.y + 1)) {
          piece.y++;
        } else {
          lockPiece();
        }
        draw();
      }

      function draw() {
        ctx.fillStyle = '#16213e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            const val = board[row][col];
            if (val) {
              ctx.fillStyle = COLORS[val];
              ctx.fillRect(col * BLOCK_SIZE + 1, row * BLOCK_SIZE + 1, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
            }
          }
        }

        if (!gameOver) {
          const shape = getPieceShape(piece.type, piece.rotation);
          ctx.fillStyle = COLORS[piece.type];
          for (let row = 0; row < shape.length; row++) {
            for (let col = 0; col < shape[row].length; col++) {
              if (!shape[row][col]) continue;
              const x = (piece.x + col) * BLOCK_SIZE + 1;
              const y = (piece.y + row) * BLOCK_SIZE + 1;
              if (piece.y + row >= 0) {
                ctx.fillRect(x, y, BLOCK_SIZE - 2, BLOCK_SIZE - 2);
              }
            }
          }
        }
      }

      function startGame() {
        board = createBoard();
        score = 0;
        gameOver = false;
        scoreEl.textContent = '0';
        gameOverEl.classList.remove('visible');
        spawnNext();
        draw();
        if (fallTimer) clearInterval(fallTimer);
        fallTimer = setInterval(tick, FALL_MS);
      }

      restartBtn.addEventListener('click', startGame);

      document.addEventListener('keydown', function (e) {
        if (gameOver) {
          if (e.key === 'r' || e.key === 'R') startGame();
          return;
        }
        const shape = getPieceShape(piece.type, piece.rotation);
        if (e.key === 'ArrowLeft' && canPlace(shape, piece.x - 1, piece.y)) {
          piece.x--;
          draw();
        } else if (e.key === 'ArrowRight' && canPlace(shape, piece.x + 1, piece.y)) {
          piece.x++;
          draw();
        } else if (e.key === 'ArrowDown') {
          if (canPlace(shape, piece.x, piece.y + 1)) {
            piece.y++;
            score += 1;
            scoreEl.textContent = score;
            draw();
          }
        } else if (e.key === 'ArrowUp' || e.key === ' ') {
          e.preventDefault();
          const nextRot = (piece.rotation + 1) % 4;
          const nextShape = getPieceShape(piece.type, nextRot);
          if (canPlace(nextShape, piece.x, piece.y)) {
            piece.rotation = nextRot;
            draw();
          }
        } else if (e.key === 'r' || e.key === 'R') {
          startGame();
        }
      });

      startGame();
    })();
  </script>
</body>
</html>
